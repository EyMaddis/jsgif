{"version":3,"sources":["GifEncoder.js"],"names":["GifEncoder","images","size","transparentColor","undefined","loopCount","fps","disposalMethod","samplingFactor","comment","onProgress","image","left","top","width","height","delayTime","rgbaPixels","CanvasRenderingContext2D","getImageData","canvas","data","ImageData","Uint8ClampedArray","Error","push","disposeUsedFrames","Promise","resolve","timeout","iterator","_encodingGenerator","runner","result","next","done","setTimeout","value","length","gifWriter","writeHeader","writeLogicalScreenDescriptor","writeCommentExtension","writeNetscapeLoopingApplicationExtension","imageEncoder","totalImages","currentImageIndex","current","total","step","encodeImage","localColorTable","transparentColorIndex","tableBasedImageData","writeImage","writeTrailer","getData","_delayTime","Number","isInteger","_disposalMethod","_loopCount","_transparentColor","_comment","_samplingFactor","_width","_height"],"mappings":"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","file":"GifEncoder.js","sourcesContent":["/**\n * This class lets you encode animated GIF files\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nimport 'babel-polyfill';\nimport GifWriter from './GifWriter.js';\nimport ImageEncoder from './ImageEncoder.js';\n\nexport default class GifEncoder {\n\tconstructor() {\n\t\tthis.images = [];\n\n\t\tthis.size = [320, 240];\n\t\tthis.transparentColor = undefined;\n\t\tthis.loopCount = undefined;\n\t\tthis.fps = 1;\n\t\tthis.disposalMethod = 0;\n\t\tthis.samplingFactor = 10;\n\t\tthis.comment = undefined;\n        this.onProgress = undefined;\n\t}\n\n\t/**\n\t * Sets the delay time between each frame, or changes it for subsequent frames\n\t * (applies to last frame added)\n\t * int delay time in milliseconds\n\t * @param milliseconds\n\t * NOT MILLISECONDS BUT 100ths of a second!!!!!\n\t */\n\tget delayTime() {\n\t\treturn this._delayTime;\n\t}\n\tset delayTime(delayTime) {\n\t\tif (!Number.isInteger(delayTime) || delayTime < 0 || delayTime > 65535) {\n\t\t\tthrow new Error('Property \"delayTime\" must be an integer between 0 and 65535.');\n\t\t}\n\n\t\tthis._delayTime = delayTime;\n\t}\n\n\t/**\n\t * * Sets frame rate in frames per second. Equivalent to\n\t * <code>setDelay(1000/fps)</code>.\n\t * @param fps\n\t * float frame rate (frames per second)\n\t */\n\tset fps(fps) {\n\t\tif (!Number.isInteger(fps)) {\n\t\t\tthrow new Error('Property \"fps\" must be an integer.');\n\t\t}\n\n\t\tif (fps == 0xF) {\n\t\t\tthrow new Error('???');\n\t\t}\n\n\t\tthis.delayTime = 100 / fps;\n\t}\n\n\t/**\n\t * Sets the GIF frame disposal code for the last added frame and any\n\t *\n\t * subsequent frames.\n\t *\n\t * 0: No disposal specified. The decoder is not required to take any action.\n\t * 1: Do not dispose. The graphic is to be left in place.\n\t * 2: Restore to background color. The area used by the graphic must be restored to the background color.\n\t * 3: Restore to previous. The decoder is required to restore the area overwritten by the graphic with what was there prior to rendering the graphic.\n\t * 4-7: To be defined.\n\t * @param code\n\t * int disposal code.\n\t */\n\tget disposalMethod() {\n\t\treturn this._disposalMethod;\n\t}\n\tset disposalMethod(disposalMethod) {\n\t\tif (!Number.isInteger(disposalMethod) || disposalMethod < 0 || disposalMethod > 7) {\n\t\t\tthrow new Error('Property \"disposalMethod\" must be an integer between 0 and 7.');\n\t\t}\n\n\t\tthis._disposalMethod = disposalMethod;\n\t}\n\n\t/**\n\t * Sets the number of times the set of GIF frames should be played. Default is\n\t * 1; 0 means play indefinitely. Must be invoked before the first image is\n\t * added.\n\t *\n\t * @param iter\n\t * int number of iterations.\n\t * @return\n\t */\n\tget loopCount() {\n\t\treturn this._loopCount;\n\t}\n\tset loopCount(loopCount) {\n\t\tif (loopCount !== undefined && !Number.isInteger(loopCount) || loopCount < 0 || loopCount > 65535) {\n\t\t\tthrow new Error('Property \"loopCount\" must be an integer between 0 and 65535 or undefined.');\n\t\t}\n\n\t\tthis._loopCount = loopCount;\n\t}\n\n\t/**\n\t * Sets the transparent color for the last added frame and any subsequent\n\t * frames. Since all colors are subject to modification in the quantization\n\t * process, the color in the final palette for each frame closest to the given\n\t * color becomes the transparent color for that frame. May be set to null to\n\t * indicate no transparent color.\n\t * @param color\n\t * Color to be treated as transparent on display.\n\t */\n\tget transparentColor() {\n\t\treturn this._transparentColor;\n\t}\n\tset transparentColor(transparentColor) {\n\t\t// TODO: Check value\n\n\t\tthis._transparentColor = transparentColor;\n\t}\n\n\t/**\n\t * Sets the comment for the block comment\n\t * @param comment\n\t * string to be insterted as comment\n\t */\n\tget comment() {\n\t\treturn this._comment;\n\t}\n\tset comment(comment) {\n\t\tif (comment !== undefined && typeof comment !== 'string') {\n\t\t\tthrow new Error('Property \"comment\" must be a string or undefined.');\n\t\t}\n\n\t\tthis._comment = comment;\n\t}\n\n\t/**\n\t * Sets quality of color quantization (conversion of images to the maximum 256\n\t * colors allowed by the GIF specification). Lower values (minimum = 1)\n\t * produce better colors, but slow processing significantly. 10 is the\n\t * default, and produces good color mapping at reasonable speeds. Values\n\t * greater than 20 do not yield significant improvements in speed.\n\t * @param quality\n\t * int greater than 0.\n\t * @return\n\t */\n\tget samplingFactor() {\n\t\treturn this._samplingFactor;\n\t}\n\tset samplingFactor(samplingFactor) {\n\t\tif (!Number.isInteger(samplingFactor) || samplingFactor < 1 || samplingFactor > 256) {\n\t\t\tthrow new Error('Property \"samplingFactor\" must be an integer between 1 and 256.');\n\t\t}\n\n\t\tthis._samplingFactor = samplingFactor;\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\tset width(width) {\n\t\tif (!Number.isInteger(width) || width < 1 || width > 65535) {\n\t\t\tthrow new Error('Property \"width\" must be an integer between 1 and 65535.');\n\t\t}\n\n\t\tthis._width = width;\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset height(height) {\n\t\tif (!Number.isInteger(height) || height < 1 || height > 65535) {\n\t\t\tthrow new Error('Property \"height\" must be an integer between 1 and 65535.');\n\t\t}\n\n\t\tthis._height = height;\n\t}\n\n\t/**\n\t * Sets the GIF frame size. The default size is the size of the first frame\n\t * added if this method is not invoked.\n\t * @param w\n\t * int frame width.\n\t * @param h\n\t * int frame width.\n\t */\n\tget size() {\n \t\treturn [this._width, this._height];\n \t}\n \tset size([width, height]) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n \t}\n\n\t/**\n\t * The addImage method takes an incoming BitmapData object to create each frames\n\t * @param\n\t * BitmapData object to be treated as a GIF's frame\n\t */\n\taddImage(image, left, top, width, height, disposalMethod, delayTime, transparentColor) {\n\t\t// Check image\n\t\tlet rgbaPixels;\n\t\tif (image instanceof CanvasRenderingContext2D) {\n\t\t\t// User passed a context\n\t\t\trgbaPixels = image.getImageData(0, 0, image.canvas.width, image.canvas.height).data;\n\t\t} else if (image instanceof ImageData) {\n\t\t\t// User passed context.getImageData(...)\n\t\t\trgbaPixels = image.data;\n\t\t} else if (image instanceof Uint8ClampedArray) {\n\t\t\t// User passed context.getImageData(...).data\n\t\t\trgbaPixels = image;\n\t\t} else {\n\t\t\tthrow new Error('Parameter \"image\" must be a CanvasRenderingContext2D, ImageData or Uint8ClampedArray.');\n\t\t}\n\n\t\tthis.images.push([rgbaPixels, left, top, width, height, disposalMethod, delayTime, transparentColor]);\n\t}\n\n\tencode(disposeUsedFrames) {\n\t\treturn new Promise((resolve) => {\n\t\t\tlet timeout;\n\t\t\tconst iterator = this._encodingGenerator(disposeUsedFrames);\n\t\t\tconst runner = () => {\n\t\t\t\tconst result = iterator.next();\n\t\t\t\tif(!result.done) {\n\t\t\t\t\ttimeout = setTimeout(runner, 0);\n                    if(this.onProgress && typeof this.onProgress === 'function') {\n                        this.onProgress(result.value);\n                    }\n                } else {\n                    resolve(result.value);\n                }\n\t\t\t};\n\t\t\trunner();\n\t\t});\n\t}\n\n\t*_encodingGenerator(disposeUsedFrames) {\n\t\tif (!this.images.length) {\n\t\t\tthrow new Error('No images added. Use addImage() to add images.');\n\t\t}\n\n\t\tconst gifWriter = new GifWriter();\n\n\t\tgifWriter.writeHeader();\n\n\t\tgifWriter.writeLogicalScreenDescriptor(\n\t\t\tthis.width,\n\t\t\tthis.height,\n\t\t\t0,\n\t\t\t7,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0,\n\t\t\t0\n\t\t);\n\n\t\tif (this.comment) {\n\t\t\tgifWriter.writeCommentExtension(this.comment);\n\t\t}\n\n\t\tif (this.loopCount !== undefined) {\n\t\t\tgifWriter.writeNetscapeLoopingApplicationExtension(this.loopCount);\n\t\t}\n\n\t\t// Initialize the ImageEncoder which will take care of generating\n\t\t// Local Color Table and LZW-encoded Table Based Image Data\n\t\tconst imageEncoder = new ImageEncoder();\n\n\t\t// Loop images\n\n\t\tconst totalImages = this.images.length;\n\t\tlet currentImageIndex = 0;\n\t\tfor (const image of this.images) {\n            yield { // progress\n                current: currentImageIndex,\n                total: totalImages,\n                step: 'encoding'\n            };\n\n\t\t\tconst [\n\t\t\t\trgbaPixels,\n\t\t\t\tleft = 0,\n\t\t\t\ttop = 0,\n\t\t\t\twidth = this.width,\n\t\t\t\theight = this.height,\n\t\t\t\tdisposalMethod = this.disposalMethod,\n\t\t\t\tdelayTime = this.delayTime,\n\t\t\t\ttransparentColor = this.transparentColor,\n\t\t\t] = image;\n\n\t\t\t// Encode the image\n\t\t\tconst [\n\t\t\t\tlocalColorTable,\n\t\t\t\ttransparentColorIndex,\n\t\t\t\ttableBasedImageData\n\t\t\t] = imageEncoder.encodeImage(rgbaPixels, this.samplingFactor, width, height, transparentColor);\n\n\t\t\tif(disposeUsedFrames) {\n\t\t\t\tthis.images[currentImageIndex] = undefined; // clear to enable garbage collection\n\t\t\t}\n\n\t\t\tyield { // progress\n                current: currentImageIndex,\n                total: totalImages,\n                step: 'writing'\n            };\n\n\t\t\t// Write the image\n\t\t\tgifWriter.writeImage(\n\t\t\t\tleft,\n\t\t\t\ttop,\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\tdisposalMethod,\n\t\t\t\tdelayTime,\n\t\t\t\ttransparentColorIndex,\n\t\t\t\tlocalColorTable,\n\t\t\t\ttableBasedImageData\n\t\t\t);\n            currentImageIndex++;\n\t\t}\n\n\t\tyield { // progress\n            current: currentImageIndex,\n            total: totalImages,\n            step: 'finishing'\n        };\n        if(disposeUsedFrames) {\n        \tthis.images = [];\n        }\n\n\t\t// Write Trailer\n\t\tgifWriter.writeTrailer();\n\n\t\treturn gifWriter.getData();\n\t}\n}\n"],"sourceRoot":"/source/"}