{"version":3,"sources":["ImageEncoder.js"],"names":["rgbaPixelsToRgbPixels","findClosestColorIndex","analyzePixels","rgbaPixels","pixelCount","length","rgbPixels","Uint8ClampedArray","i","colorTable","color","usedEntry","r","g","b","minpos","dmin","len","dr","dg","db","d","index","pixels","sample","nPix","indexedPixels","nq","colorTab","process","k","j","map","ImageEncoder","width","height","transparentColor","localColorTable","tableBasedImageDataBytes","lzwEncoder","encode","transparentColorIndex","undefined","bytes"],"mappings":"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","file":"ImageEncoder.js","sourcesContent":["import LZWEncoder from './LZWEncoder.js';\nimport NeuQuant from './NeuQuant.js';\nimport ByteArray from './ByteArray.js';\n\nexport function rgbaPixelsToRgbPixels(rgbaPixels) {\n\tconst pixelCount = rgbaPixels.length / 4;\n\tconst rgbPixels = new Uint8ClampedArray(pixelCount * 3);\n\n\tfor (let i = 0; i < pixelCount; i++) {\n\t\trgbPixels[i * 3 + 0] = rgbaPixels[i * 4 + 0];\n\t\trgbPixels[i * 3 + 1] = rgbaPixels[i * 4 + 1];\n\t\trgbPixels[i * 3 + 2] = rgbaPixels[i * 4 + 2];\n\t}\n\n\treturn rgbPixels;\n}\n\nexport function findClosestColorIndex(colorTable, color, usedEntry) {\n\tif (!colorTable) {\n\t\treturn -1;\n\t}\n\n\tconst r = (color & 0xFF0000) >> 16;\n\tconst g = (color & 0x00FF00) >> 8;\n\tconst b = (color & 0x0000FF);\n\n\tvar minpos = 0;\n\tvar dmin = 256 * 256 * 256;\n\tvar len = colorTable.length;\n\n\tfor (var i = 0; i < len;) {\n\t\tvar dr = r - (colorTable[i++] & 0xff);\n\t\tvar dg = g - (colorTable[i++] & 0xff);\n\t\tvar db = b - (colorTable[i] & 0xff);\n\t\tvar d = dr * dr + dg * dg + db * db;\n\t\tvar index = i / 3;\n\t\tif (usedEntry[index] && (d < dmin)) {\n\t\t\tdmin = d;\n\t\t\tminpos = index;\n\t\t}\n\t\ti++;\n\t}\n\treturn minpos;\n}\n\nexport function analyzePixels(pixels, sample, usedEntry) {\n\tvar len = pixels.length;\n\tvar nPix = len / 3;\n\tconst indexedPixels = [];\n\tvar nq = new NeuQuant(pixels, len, sample);\n\n\t// initialize quantizer\n\tconst colorTab = nq.process(); // create reduced palette\n\n\t// map image pixels to new palette\n\tvar k = 0;\n\tfor (var j = 0; j < nPix; j++) {\n\t\tvar index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\n\t\tusedEntry[index] = true;\n\t\tindexedPixels[j] = index;\n\t}\n\n\treturn [colorTab, indexedPixels];\n}\n\nexport default class ImageEncoder {\n  constructor() {\n    this.usedEntry = [];\n  }\n\n  encodeImage(rgbaPixels, sample, width, height, transparentColor) {\n    // Remove alpha channel from pixel array\n    const rgbPixels = rgbaPixelsToRgbPixels(rgbaPixels);\n\n    // Analyze pixels\n    const [\n      localColorTable,\n      indexedPixels,\n    ] = analyzePixels(rgbPixels, sample, this.usedEntry);\n\n    // Encode the pixels\n    const tableBasedImageDataBytes = new ByteArray();\n    var lzwEncoder = new LZWEncoder(width, height, indexedPixels, 8);\n    lzwEncoder.encode(tableBasedImageDataBytes);\n\n    // Get closest match to the specified transparent color\n    let transparentColorIndex;\n    if (transparentColor !== undefined) {\n      transparentColorIndex = findClosestColorIndex(localColorTable, transparentColor, this.usedEntry);\n    }\n\n    return [\n      localColorTable,\n      transparentColorIndex,\n      tableBasedImageDataBytes.bytes,\n    ];\n  }\n}\n"],"sourceRoot":"/source/"}